# 언어론 공부

## 언어론 소개

### 프로그래밍 도메인

1. 과학 계산
    - 다양한 실수형 연산
2. 기업 경영
    - 보고서 작성, 10진수 및 문자열을 주로 다룸
3. 인공지능
    - 수 보다는 심볼을 주로 다룸
4. 시스템 프로그래밍
    - 운영체제와 같은 시스템 소프트웨어는 항상 실행상태에 있으므로 효율적이어야 한다.
5. 웹 소프트웨어
    - **갓언어 PHP**

### 프로그래밍 언어의 범주

1. 명령형 (Imperative)
    - 주로 변수, 할당문, 반복문 등을 이용하여 프로그램을 작성함.
2. 함수형 (Functional)
    - 매개변수를 받아 실행하는 함수를 이용하여 프로그램을 작성함.
3. 논리형 (Logical)
    - 순서가 중요하지 않는 규칙을 기반으로(rule-based) 프로그램을 작성함.
4. 객체지향형 (Object-oriented)
    - 명령형 언어에 기반
    - 데이터의 캡슐화 (encapsulation), 속성의 상속 (inheritance), 동적 타입 바인딩 등을 이용하여 프로그램을 작성함

## 언어 평가 기준

1. 가독성 (Readability)
    1. 간결성 (Simplicity)
        - 너무 많은 종류의 문장을 지원하는 언어는 좋지 않다
        - 동일한 기능의 연산 표현 방법이 많을수록 좋지 않다
        - 연산자 오버로딩은 프로그램을 이해하는데 좋지 않은 기능이다
        - 함수형 언어가 간결성에서 우수함
    2. 직교성 (Orthogonality)
        - 수학에서 직교하다와 같은 의미
        - 언어의 모든 구성 요소를 임의로 조합해서 프로그램을 작성할 수 있는 기능
        - 직교성이 부족: 구성 요소의 사용 규칙에 예외적인 경우가 많음
        - 완벽에 가까운 직교성: 상식적이지 않은 조합은 표현이 복잡해져 가독성을 저하시킬 수 있음
        - 함수형 언어가 직교성에서 우수함.
    3. 제어문 (Control statements)
        - goto문이 있는데 가독성에 좋지 않음
        - if-then-else나 while 등의 구조적 프로그래밍 구조를 지원하면서 제어문의 중요성은 저하되었다.
    4. 데이터 타입과 구조체 (Data types and Structures)
        - 적절한 data type이 지원되어야 하고 새로운 자료구조를 data type으로 정의할 수 있어야 한다.
    5. 문법의 구문 (Syntax)
        - 식별자(Identifier)의 형태
            - 길이에 제한이 있는 경우 가독성이 떨어진다
            - 특수 문자를 식별자에 사용가능하면 가독성이 좋다. (`_` 등)
        - 특수 단어 (Special words)
            - 의미를 자연스럽게 알 수 있는 특수 단어들은 가독성에 좋다.
        - 형식과 의미 (Form and meaning)
            - 포현 형식은 같거나 비슷한데 경우에 따라 다른 의미를 가지면 가독성이 떨어진다.
2. 작성력 (Writability)
    1. 간결성 (Simplicity)
        - 소수의 구성 요소
        - 구성 요소들의 조합에 대한 소수의 규칙
    2. 직교성 (Orthogonality)
        - 모든 구성 요소의 임의의 조합이 가능하므로 작성력이 좋다.
        - 지나친 직교성은 작성력에는 좋을지라도 가독성에 좋지 않은 면이 있다.
    3. 추상화 (Abstraction) 지원
        1. 데이터의 추상화 (Data abstraction)
            - 복잡한 자료구조를 정의해서 사용할 수 있는 기능 지원
        2. 프로세스의 추상화 (Process abstraction)
            - 복잡한 연산을 정의해서 사용할 수 있는 기능 지원 (function, procedure 등)
    4. 표현력 (Expressivity)
        - 기존의 구성 요소와 동일한 기능을 수행하지만 좀 더 편리한 구문 지원
            - 중첩된 if-then-else 대신 switch문
            - counter를 사용하는 while 대신 for문
        - APL 언어는 매우 강력한 연산자를 지원함
            - 하나의 연산으로 행렬 더하기 곱하기 전치행렬 구하기 등이 된다
            - 작성력은 매우 뛰어나나 가독성이 매우 떨어짐
3. 신뢰성 (Reliability)
    1. **Type checking**
        - 컴파일할 때나 프로그램 실행 시 타입 에러를 검출함.
        - 일찍 발견할수록 오류 수정 비용이 적다.
    2. 예외 처리 (Exception handling)
        - 프로그램 실행시 런타임 에러가 발생한 경우, 이를 인식하고 오류를 처리할 수 있는 필요한 조치를 취할 수 있는 기능
    3. Aliasing
        - 메모리의 한 저장 장소를 여러 이름으로 접근할 수 있는 기능 (C의 union 등)
        - 신뢰성에 부정적인 영향을 끼친다.
    4. 가독성과 작성력
        - 작성하기 쉽고 이해하기 쉬운 프로그램을 작성할 수 있는 언어로 작성된 프로그램은 오류 가능성이 적다.
4. 비용 (Cost)
    1. 프로그래머 양성 비용
        - 간결성과 직교성의 영향을 받음
    2. **프로그램 개발 비용**
        - 작성력과 특정 응용분야와의 밀접성의 영향을 받음
    3. 프로그램의 컴파일 비용
    4. 프로그램의 실행 비용
        - 언어 설계의 영향을 받음
        - 컴파일 비용과 상충관계
    5. 컴파일러/인터프리터의 비용
        - 언어 구현 시스템이 저렴하면 널리 사용됨
    6. **신뢰성**
        - 신뢰도가 낮은 언어로 작성된 프로그램은 오류로 인한 비용 부담이 매우 크다
    7. **유지보수 (maintenance) 비용**
        - 가독성과 작성력의 영향을 받음

## 구문구조

### 구문구조와 의미구조

- 정형언어
    - 프로그래밍 언어는 정형 언어이다. (vs, 자연언어)
    - 정형 언어는 자연언어보다 명확하고 모호하지 않은 형태와 의미를 가진다.

1. 프로그래밍 언어
    - 프로그램들의 집합
2. 알파벳
    - 어떤 언어의 문장을 만드는 데에 사용할 수 있는 모든 문자들의 집합
3. 문법
    - 어떤 언어의 알파벳으로부터 문장을 만들기 위해 사용하는 규칙들의 집합
4. 구문 분석
    - 어떤 문장이 어떤 언어의 원소인지, 즉 문법을 만족하는 지를 분석하는 과정

### 문자열 집합과 연산

> ε 는 빈 문자열

- 문자열 접합 연산
    - `"ab" . "cd" = "abcd"`
    - `"ab" . ε = ε . "ab" = "ab"`
- 문자열 집합 접합 연산
    - `{"a", "ab"} . {"c", "d"} = {"ac", "ad", "abc", "abd"}`
    - `{"a", "b"} . {} = {} . {"a", "b"} = {"a", "b"}`
    - `{"a", "b"} . {ε, "c"} = {"a", "ac", "b", "bc"}`
- 문자열 연산의 간략형
    - `{a, b} . {a, b} = {a, b}² = {aa, ab, ba, bb}`
    - `{a, b} . {a, b} . {a, b} = {a, b}³ = {aaa, aab, aba, abb, baa, bab, bba, bbb}`
    - `{a, b}¹ = {a, b}`
    - `{a, b}^0 = {ε}`
- 클레이니 클로저 (Kleene Closure)
    - `{a, b}* = {a, b}ⁿ = {a, b}^0 ∪ {a, b}¹ ∪ {a, b}² ∪ ...` (문자 a, b로 이루어진 모든 문자열들의 집합)

### 언어 집합

#### 간단한 언어 Simple

- 언어 Simple의 알파벳 `Σ = {a, b}`
- `Simple = {a, ab, abb, abbb, abbbb, ...}`
- `Simple ⊆ Σ*`
- `Simple = {w|문자열 w는 어떤 조건을 만족한다} = {w|문자열 w는 맨 앞에 a가 나오고 그 다음에 0개 이상의 b가 나온다}`

#### 귀납 정의

- 무한 집합 Simple을 유한하게 작성하는 방법
- 추론 규칙
    - `a ∈ Simple` (공리)
    - `w ∈ Simple 이면 wb ∈ Simple` (추론규칙)
    - abb가 Simple의 원소임을 증명하려면?
        1. `a ∈ Simple`
        2. `ab ∈ Simple`
        3. `abb ∈ Simple`
- 생성 규칙: 화살표 기반의 기호열을 우변의 기호열로 교체할 수 있음을 의미
    - `S -> a`
    - `S -> Sb`
    - 문장 abb가 Simple의 원소임을 증명하는 유도 (derivation)
        - `S -> Sb -> Sbb -> abb`
    - 문장형태 (sentential form): 시작기호로부터 문장에 이르기까지 유도에 등장하는 기호열
    - 문장 abb가 Simple의 원소임을 증명하는 파스트리
    ```
       S
      / \
     S   \
    /  \  |
    S  |  |
    |  |  |
    a  b  b
    ```

### 언어의 문법

- 정형 문법 G=(T, N, S, P)
    1. 터미널 기호 집합 T
    2. 넌터미널 기호 집합 N
    3. 시작 기호 S
    4. 생성규칙의 집합 P

- Simple의 정형 문법 G
    1. `T = {a, b}`
    2. `N = {S}`
    3. `S`
    4. `P = {S->a, S->Sb}`
        혹은 `P = {S -> a | Sb}`

- 다른 언어 G2의 문법
    1. `T = {a, b}`
    2. `N = {S, A, B}`
    3. `S`
    4. 생성규칙의 집합 P
        - S -> aAb | aBb
        - A -> aA | ε
        - B -> bB | ε
    ```
    L(G2) = {ab, aab, aaab, ..., abb, abbb, ...}
    ```

> 생성규칙에서 각 넌터미널은 하나의 부분언어 집합을 나타낸다.

#### BNF 구문 정의

- BNF (Backus-Naur Form)
    - 프로그래밍 언어의 문법을 표현하기 위한 표기법
    - Algol 60 정의에 처음 사용함
    - 프로그래밍 언어의 대부분을 표기하기 위해 사용함


- 간단한 예제 프로그래밍 언어를 위한 문법
    ```bnf
    <program> ::= <stmts>
    <stmts> ::= <stmt> | <stmt> ; <stmts>
    <stmt> ::= <var> = <expr>
    <var> ::= a | b | c | d
    <expr> ::= <term> + <term> | <term>
    <term> ::= <var> | const
    ```
    - `a = a + b ; b = c`
        ```
        유도: <program> -> <stmts>
        -> <stmt> ; <stmts>
        -> <var> = <expr> ; <stmts>
        -> a = <expr> ; <stmts>
        -> a = <term> + <term> ; <stmts>
        -> a = <var> + <term> ; <stmts>
        -> a = a + <term> ; <stmts>
        -> a = a + <var> ; <stmts>
        -> a = a + b ; <stmts>
        -> a = a + b ; <stmt>
        -> a = a + b ; <var> = <expr>
        -> a = a + b ; b = <expr>
        -> a = a + b ; b = <term>
        -> a = a + b ; b = <var>
        -> a = a + b ; b = c
        ```
        - 좌(우)우선 유도(left(right) most derivation) : 유도 단계마다 맨 왼쪽(오른쪽)에 위치한 넌터미널을 대치함
        - 좌우선이든 우우선이든 파스트리는 동일하게 생성됨
        - 파스트리
        ```
                               <program>
                                   |
                                <stmts>
                  /                |         \
             <stmts>               |        <stmts>
          /    |      \            |           |
        <var>  |      <expr>       |        <stmts>
          |    |    /    |    \    |      /    |    \
          |    |  <term> | <term>  |    <var>  |  <expr>
          |    |    |    |    |    |      |    |    |
          |    |   <var> |  <var>  |      |    |  <term>
          |    |    |    |    |    |      |    |    |
          |    |    |    |    |    |      |    |   <var>
          |    |    |    |    |    |      |    |    |
          a    =    a    +    b    ;      b    =    c
        ```

### 모호한 문법

- 모호한 문법: 주어진 문장에 대한 두 개 이상의 파스트리가 가능

### EBNF

- EBNF (Extended BNF)
    - BNF 표기법에 다양한 매크로를 추가하여 편리하게 사용할 수 있도록 함
    - 반복 { }
        - 0번 또는 그 이상의 반복
    - 옵션 [ ]
        - 한 번 나오거나 나오지 않음
    - 다중 선택 ( )
        - 여러 개에서 하나를 선택함

### 추상구문트리 (Abstract Syntax Tree)

- 파스트리(구체구문트리)는 문장의 유도과정이 모두 들어있어서 추후의 다른 작업을 하기에 복잡하다
- 추상구문트리는 넌터미널 기호를 제거하고 터미널로만 이루어진 표현으로 간략화한 것

> 파스트리
```
       <exp> 
    /   |      \
<exp>   -      <exp>
  |           /  |  \ 
<digit>    <exp> * <exp>    
  |          |       | 
  3       <digit> <digit>
             |       |
             5       7 
```

> 추상구문트리
```
  -
 / \
3  *
  / \
  5 7  
```

### 언어와 인식 기계

- 인식 기계: 주어진 문장이 주어진 언어에 속하는지를 자동으로 결정하는 알고리즘
    - 자동기계(automata)라고 불리는 특수한 알고리즘

- 문법 분류 (Chomsky의 분류):
    다음을 가정할 때
    ```
    A, B ∈ N
    a ∈ T
    α, β, γ ∈ (N ∪ T)*
    ```
    문법의 형태에 따라서 다음과 같이 분류함
    1. 타입 0: 무제한 문법 (unresetricted grammar)
        - `α -> β`
        - 생성규칙 형태에 제한이 없음
    2. 타입 1: 문맥 민감 문법 (context sensitive grammar)
        - `αAβ -> αγβ`
        - α와 β에 둘러쌓였을 때만 A를 γ로 대치할 수 있음
    3. 타입 2: 문맥 자유 문법 (context free grammar)
        - `A -> α`
        - 언제든지 A를 α로 대치할 수 있음
    4. 타입 3. 정규 문법 (regular grammar)
        - `A -> a | Ba`
        - A를 단 하나의 터미널이나 넌터미널 하나와 터미널 하나로 된 문장형태로 대치할 수 있음
    
    - 정규문법 ⊆ 문맥자유문법 ⊆ 문맥민감문법 ⊆ 무제한문법
    
- 문법, 언어, 기계
    |문법|언어|자동기계|
    |----|---|---|
    |타입 0: 무제한 문법|재귀나열 언어 (recursively enumerable language)|튜링 기계 (Turing machine)|
    |타입 1: 문맥민감 문법|문맥민감 언어 (context-sensitive language)|선형 바운드 오토마타 (linear-bounded automata)|
    |타입 2: 문맥자유 문법|문맥자유 언어 (context-free language)|푸쉬다운 오토마타 (push-down automata)|
    |타입3: 정규 문법|정규 언어 (regular language)|유한 상태 기계 (linear state machine)|

    - 정규문법 ⊆ 문맥자유문법 ⊆ 문맥민감문법 ⊆ 무제한문법
    - 정규언어 ⊆ 문맥자유언어 ⊆ 문맥민감언어 ⊆ 재귀나열언어
    - 유한상태기계 ⊆ 푸쉬다운 오토마타 ⊆ 선형 바운드 오토마타 ⊆ 튜링 기계

- 프로그래밍 언어의 구문 분석
    - 프로그래밍 언어의 문법은 정규 문법과 문맥자유문법이면 표현하기 충분함
    - 프로그래밍 언어의 구문 분석은 유한 상태 기계와 푸쉬다운 오토마타를 이용
    - 컴파일러의 구문구조 분석 단계
        1. 어휘 분석 (lexical analysis, scanning)
            - 프로그램 어휘들을 정규 문법으로 표현하고 유한 상태 기계로 인식함
        2. 구문 분석 (syntatic analysis, parsing)
            - 프로그램 구조를 문맥자유 문법으로 표현하고 푸쉬다운 오토마타로 인식함

## 변수의 속성

- von Neumann 구조
    - 명령형 언어는 폰노이만 구조의 컴퓨터를 구현한 형태이다.
        - 폰 노이만 구조 : 명령형언어
        - 메모리 : 변수
        - 프로세서 : 수식 연산

- 변수의 속성
    1. 이름 (name)
        - 무명 변수 (Anonymous Variable)
            - 이름이 주어지지 않는 변수도 있을 수 있다.
            ```
            int *p = (int *) malloc(sizeof(int));
            // 동적할당된 무명변수를 *p로 접근할 수 있다.
            ```
    2. 타입 (type)
        - 타입으로부터 알 수 있는 정보
            - 값의 범위 (range of values)
            - 적용 가능한 연산의 종류 (set of operations)
            - 유효숫자의 범위 (precision): 실수형의 경우
            - 16-bit 정수형으로 알 수 있는 정보:
                1. 값의 범위: -32768 ~ 32767
                2. 연산의 종류: +, -, *, /, mod, ...
            - Stack class로부터 알 수 있는 정보:
                1. 값의 범위: class 내에 member 데이터로 선언된 변수의 타입에 따라 좌우된다.
                2. 연산의 종류: class 내에 member 함수로 선언된 pop, push, ...
    3. 주소 (address)
        - 프로그램에서 사용되는 변수는 타입 크기만큼의 기억장소가 대응된다.
        - 변수에 대응된 기억장치의 주소를 변수의 주소라고 한다.
        - 한 변수의 주소는 실행 시점에 따라 다를 수 있다.
        - 동일한 이름의 변수는 프로그램에서 사용된 위치에 따라 주소가 다를 수 있다.
        ```
        int x;              // 전역변수
        foo() { int x; }    // foo의 지역변수
        goo() { int x; }    // goo의 지역분수
        ```
        - 하나의 기억장소에 여러개의 변수 이름이 대응될 수 있다. (alias 현상)
            - 가동성 저하
    4. 값 (value)
        - 변수에 대응되어 있는 기억장소에 저장되어 있는 값
        - 변수의 값의 종류:
            1. 변수의 l-value: 변수의 주소 (address)
            2. 변수의 r-value: 변수의 값 (value)
            ```
            int k;
            k = 3; // k: l-value
            k = k + 5; // 왼쪽 k는 l-value 오른쪽 k는 r-value
            ```
        - 인자전달 (parameter passing)
            1. Call-by-value (값-전달): r-value를 전달
            2. Call-by-reference (참조-전달): l-value를 전달
    5. 영역 (scope)
    6. 존속기간 (lifetime)
- Alias (별칭)
    - 여러개의 이름으로 변수에 접근할 수 있는 것을 alias라 한다.
    - Alias 현상이 발생하는 경우
        - Pointer 사용
            ```
            int *p, *q;
            p = q = (int *)malloc(...);
            ```
        - 참조변수 (Reference variable) 사용
            ```
            int ans;
            int &ref_ans = ans;
            ```
        - union 사용
            ```
            union {
                int p;
                float q;
            } a;
            ```
        - Call-by-Reference에 의한 인자 전달
            ```
            void foo(int &x, ...) { ... }
            main() {
                int a;
                foo(a, ...);
                ...
            }
            ```
- 바인딩 (Binding)
    - 변수에 속성을 부여하는 것을 바인딩이라고 한다.
