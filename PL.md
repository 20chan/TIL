# 언어론 공부

## 언어론 소개

### 프로그래밍 도메인

1. 과학 계산
    - 다양한 실수형 연산
2. 기업 경영
    - 보고서 작성, 10진수 및 문자열을 주로 다룸
3. 인공지능
    - 수 보다는 심볼을 주로 다룸
4. 시스템 프로그래밍
    - 운영체제와 같은 시스템 소프트웨어는 항상 실행상태에 있으므로 효율적이어야 한다.
5. 웹 소프트웨어
    - **갓언어 PHP**

### 프로그래밍 언어의 범주

1. 명령형 (Imperative)
    - 주로 변수, 할당문, 반복문 등을 이용하여 프로그램을 작성함.
2. 함수형 (Functional)
    - 매개변수를 받아 실행하는 함수를 이용하여 프로그램을 작성함.
3. 논리형 (Logical)
    - 순서가 중요하지 않는 규칙을 기반으로(rule-based) 프로그램을 작성함.
4. 객체지향형 (Object-oriented)
    - 명령형 언어에 기반
    - 데이터의 캡슐화 (encapsulation), 속성의 상속 (inheritance), 동적 타입 바인딩 등을 이용하여 프로그램을 작성함

## 언어 평가 기준

1. 가독성 (Readability)
    1. 간결성 (Simplicity)
        - 너무 많은 종류의 문장을 지원하는 언어는 좋지 않다
        - 동일한 기능의 연산 표현 방법이 많을수록 좋지 않다
        - 연산자 오버로딩은 프로그램을 이해하는데 좋지 않은 기능이다
        - 함수형 언어가 간결성에서 우수함
    2. 직교성 (Orthogonality)
        - 수학에서 직교하다와 같은 의미
        - 언어의 모든 구성 요소를 임의로 조합해서 프로그램을 작성할 수 있는 기능
        - 직교성이 부족: 구성 요소의 사용 규칙에 예외적인 경우가 많음
        - 완벽에 가까운 직교성: 상식적이지 않은 조합은 표현이 복잡해져 가독성을 저하시킬 수 있음
        - 함수형 언어가 직교성에서 우수함.
    3. 제어문 (Control statements)
        - goto문이 있는데 가독성에 좋지 않음
        - if-then-else나 while 등의 구조적 프로그래밍 구조를 지원하면서 제어문의 중요성은 저하되었다.
    4. 데이터 타입과 구조체 (Data types and Structures)
        - 적절한 data type이 지원되어야 하고 새로운 자료구조를 data type으로 정의할 수 있어야 한다.
    5. 문법의 구문 (Syntax)
        - 식별자(Identifier)의 형태
            - 길이에 제한이 있는 경우 가독성이 떨어진다
            - 특수 문자를 식별자에 사용가능하면 가독성이 좋다. (`_` 등)
        - 특수 단어 (Special words)
            - 의미를 자연스럽게 알 수 있는 특수 단어들은 가독성에 좋다.
        - 형식과 의미 (Form and meaning)
            - 포현 형식은 같거나 비슷한데 경우에 따라 다른 의미를 가지면 가독성이 떨어진다.
2. 작성력 (Writability)
    1. 간결성 (Simplicity)
        - 소수의 구성 요소
        - 구성 요소들의 조합에 대한 소수의 규칙
    2. 직교성 (Orthogonality)
        - 모든 구성 요소의 임의의 조합이 가능하므로 작성력이 좋다.
        - 지나친 직교성은 작성력에는 좋을지라도 가독성에 좋지 않은 면이 있다.
    3. 추상화 (Abstraction) 지원
        1. 데이터의 추상화 (Data abstraction)
            - 복잡한 자료구조를 정의해서 사용할 수 있는 기능 지원
        2. 프로세스의 추상화 (Process abstraction)
            - 복잡한 연산을 정의해서 사용할 수 있는 기능 지원 (function, procedure 등)
    4. 표현력 (Expressivity)
        - 기존의 구성 요소와 동일한 기능을 수행하지만 좀 더 편리한 구문 지원
            - 중첩된 if-then-else 대신 switch문
            - counter를 사용하는 while 대신 for문
        - APL 언어는 매우 강력한 연산자를 지원함
            - 하나의 연산으로 행렬 더하기 곱하기 전치행렬 구하기 등이 된다
            - 작성력은 매우 뛰어나나 가독성이 매우 떨어짐
3. 신뢰성 (Reliability)
    1. **Type checking**
        - 컴파일할 때나 프로그램 실행 시 타입 에러를 검출함.
        - 일찍 발견할수록 오류 수정 비용이 적다.
    2. 예외 처리 (Exception handling)
        - 프로그램 실행시 런타임 에러가 발생한 경우, 이를 인식하고 오류를 처리할 수 있는 필요한 조치를 취할 수 있는 기능
    3. Aliasing
        - 메모리의 한 저장 장소를 여러 이름으로 접근할 수 있는 기능 (C의 union 등)
        - 신뢰성에 부정적인 영향을 끼친다.
    4. 가독성과 작성력
        - 작성하기 쉽고 이해하기 쉬운 프로그램을 작성할 수 있는 언어로 작성된 프로그램은 오류 가능성이 적다.
4. 비용 (Cost)
    1. 프로그래머 양성 비용
        - 간결성과 직교성의 영향을 받음
    2. **프로그램 개발 비용**
        - 작성력과 특정 응용분야와의 밀접성의 영향을 받음
    3. 프로그램의 컴파일 비용
    4. 프로그램의 실행 비용
        - 언어 설계의 영향을 받음
        - 컴파일 비용과 상충관계
    5. 컴파일러/인터프리터의 비용
        - 언어 구현 시스템이 저렴하면 널리 사용됨
    6. **신뢰성**
        - 신뢰도가 낮은 언어로 작성된 프로그램은 오류로 인한 비용 부담이 매우 크다
    7. **유지보수 (maintenance) 비용**
        - 가독성과 작성력의 영향을 받음

## 구문구조

### 구문구조와 의미구조

- 정형언어
    - 프로그래밍 언어는 정형 언어이다. (vs, 자연언어)
    - 정형 언어는 자연언어보다 명확하고 모호하지 않은 형태와 의미를 가진다.

1. 프로그래밍 언어
    - 프로그램들의 집합
2. 알파벳
    - 어떤 언어의 문장을 만드는 데에 사용할 수 있는 모든 문자들의 집합
3. 문법
    - 어떤 언어의 알파벳으로부터 문장을 만들기 위해 사용하는 규칙들의 집합
4. 구문 분석
    - 어떤 문장이 어떤 언어의 원소인지, 즉 문법을 만족하는 지를 분석하는 과정

### 문자열 집합과 연산

> ε 는 빈 문자열

- 문자열 접합 연산
    - `"ab" . "cd" = "abcd"`
    - `"ab" . ε = ε . "ab" = "ab"`
- 문자열 집합 접합 연산
    - `{"a", "ab"} . {"c", "d"} = {"ac", "ad", "abc", "abd"}`
    - `{"a", "b"} . {} = {} . {"a", "b"} = {"a", "b"}`
    - `{"a", "b"} . {ε, "c"} = {"a", "ac", "b", "bc"}`
- 문자열 연산의 간략형
    - `{a, b} . {a, b} = {a, b}² = {aa, ab, ba, bb}`
    - `{a, b} . {a, b} . {a, b} = {a, b}³ = {aaa, aab, aba, abb, baa, bab, bba, bbb}`
    - `{a, b}¹ = {a, b}`
    - `{a, b}^0 = {ε}`
- 클레이니 클로저 (Kleene Closure)
    - `{a, b}* = {a, b}ⁿ = {a, b}^0 ∪ {a, b}¹ ∪ {a, b}² ∪ ...` (문자 a, b로 이루어진 모든 문자열들의 집합)

### 언어 집합

#### 간단한 언어 Simple

- 언어 Simple의 알파벳 `Σ = {a, b}`
- `Simple = {a, ab, abb, abbb, abbbb, ...}`
- `Simple ⊆ Σ*`
- `Simple = {w|문자열 w는 어떤 조건을 만족한다} = {w|문자열 w는 맨 앞에 a가 나오고 그 다음에 0개 이상의 b가 나온다}`

#### 귀납 정의

- 무한 집합 Simple을 유한하게 작성하는 방법
- 추론 규칙
    - `a ∈ Simple` (공리)
    - `w ∈ Simple 이면 wb ∈ Simple` (추론규칙)
    - abb가 Simple의 원소임을 증명하려면?
        1. `a ∈ Simple`
        2. `ab ∈ Simple`
        3. `abb ∈ Simple`
- 생성 규칙: 화살표 기반의 기호열을 우변의 기호열로 교체할 수 있음을 의미
    - `S -> a`
    - `S -> Sb`
    - 문장 abb가 Simple의 원소임을 증명하는 유도 (derivation)
        - `S -> Sb -> Sbb -> abb`
    - 문장형태 (sentential form): 시작기호로부터 문장에 이르기까지 유도에 등장하는 기호열
    - 문장 abb가 Simple의 원소임을 증명하는 파스트리
    ```
       S
      / \
     S   \
    /  \  |
    S  |  |
    |  |  |
    a  b  b
    ```

### 언어의 문법

- 정형 문법 G=(T, N, S, P)
    1. 터미널 기호 집합 T
    2. 넌터미널 기호 집합 N
    3. 시작 기호 S
    4. 생성규칙의 집합 P

- Simple의 정형 문법 G
    1. `T = {a, b}`
    2. `N = {S}`
    3. `S`
    4. `P = {S->a, S->Sb}`
        혹은 `P = {S -> a | Sb}`

- 다른 언어 G2의 문법
    1. `T = {a, b}`
    2. `N = {S, A, B}`
    3. `S`
    4. 생성규칙의 집합 P
        - S -> aAb | aBb
        - A -> aA | ε
        - B -> bB | ε
    ```
    L(G2) = {ab, aab, aaab, ..., abb, abbb, ...}
    ```

> 생성규칙에서 각 넌터미널은 하나의 부분언어 집합을 나타낸다.

#### BNF 구문 정의

- BNF (Backus-Naur Form)
    - 프로그래밍 언어의 문법을 표현하기 위한 표기법
    - Algol 60 정의에 처음 사용함
    - 프로그래밍 언어의 대부분을 표기하기 위해 사용함


- 간단한 예제 프로그래밍 언어를 위한 문법
    ```bnf
    <program> ::= <stmts>
    <stmts> ::= <stmt> | <stmt> ; <stmts>
    <stmt> ::= <var> = <expr>
    <var> ::= a | b | c | d
    <expr> ::= <term> + <term> | <term>
    <term> ::= <var> | const
    ```
    - `a = a + b ; b = c`
        ```
        유도: <program> -> <stmts>
        -> <stmt> ; <stmts>
        -> <var> = <expr> ; <stmts>
        -> a = <expr> ; <stmts>
        -> a = <term> + <term> ; <stmts>
        -> a = <var> + <term> ; <stmts>
        -> a = a + <term> ; <stmts>
        -> a = a + <var> ; <stmts>
        -> a = a + b ; <stmts>
        -> a = a + b ; <stmt>
        -> a = a + b ; <var> = <expr>
        -> a = a + b ; b = <expr>
        -> a = a + b ; b = <term>
        -> a = a + b ; b = <var>
        -> a = a + b ; b = c
        ```
        - 좌(우)우선 유도(left(right) most derivation) : 유도 단계마다 맨 왼쪽(오른쪽)에 위치한 넌터미널을 대치함
        - 좌우선이든 우우선이든 파스트리는 동일하게 생성됨
        - 파스트리
        ```
                               <program>
                                   |
                                <stmts>
                  /                |         \
             <stmts>               |        <stmts>
          /    |      \            |           |
        <var>  |      <expr>       |        <stmts>
          |    |    /    |    \    |      /    |    \
          |    |  <term> | <term>  |    <var>  |  <expr>
          |    |    |    |    |    |      |    |    |
          |    |   <var> |  <var>  |      |    |  <term>
          |    |    |    |    |    |      |    |    |
          |    |    |    |    |    |      |    |   <var>
          |    |    |    |    |    |      |    |    |
          a    =    a    +    b    ;      b    =    c
        ```

### 모호한 문법

- 모호한 문법: 주어진 문장에 대한 두 개 이상의 파스트리가 가능

### EBNF

- EBNF (Extended BNF)
    - BNF 표기법에 다양한 매크로를 추가하여 편리하게 사용할 수 있도록 함
    - 반복 { }
        - 0번 또는 그 이상의 반복
    - 옵션 [ ]
        - 한 번 나오거나 나오지 않음
    - 다중 선택 ( )
        - 여러 개에서 하나를 선택함

### 추상구문트리 (Abstract Syntax Tree)

- 파스트리(구체구문트리)는 문장의 유도과정이 모두 들어있어서 추후의 다른 작업을 하기에 복잡하다
- 추상구문트리는 넌터미널 기호를 제거하고 터미널로만 이루어진 표현으로 간략화한 것

> 파스트리
```
       <exp> 
    /   |      \
<exp>   -      <exp>
  |           /  |  \ 
<digit>    <exp> * <exp>    
  |          |       | 
  3       <digit> <digit>
             |       |
             5       7 
```

> 추상구문트리
```
  -
 / \
3  *
  / \
  5 7  
```

### 언어와 인식 기계

- 인식 기계: 주어진 문장이 주어진 언어에 속하는지를 자동으로 결정하는 알고리즘
    - 자동기계(automata)라고 불리는 특수한 알고리즘

- 문법 분류 (Chomsky의 분류):
    다음을 가정할 때
    ```
    A, B ∈ N
    a ∈ T
    α, β, γ ∈ (N ∪ T)*
    ```
    문법의 형태에 따라서 다음과 같이 분류함
    1. 타입 0: 무제한 문법 (unresetricted grammar)
        - `α -> β`
        - 생성규칙 형태에 제한이 없음
    2. 타입 1: 문맥 민감 문법 (context sensitive grammar)
        - `αAβ -> αγβ`
        - α와 β에 둘러쌓였을 때만 A를 γ로 대치할 수 있음
    3. 타입 2: 문맥 자유 문법 (context free grammar)
        - `A -> α`
        - 언제든지 A를 α로 대치할 수 있음
    4. 타입 3. 정규 문법 (regular grammar)
        - `A -> a | Ba`
        - A를 단 하나의 터미널이나 넌터미널 하나와 터미널 하나로 된 문장형태로 대치할 수 있음
    
    - 정규문법 ⊆ 문맥자유문법 ⊆ 문맥민감문법 ⊆ 무제한문법
    
- 문법, 언어, 기계
    |문법|언어|자동기계|
    |----|---|---|
    |타입 0: 무제한 문법|재귀나열 언어 (recursively enumerable language)|튜링 기계 (Turing machine)|
    |타입 1: 문맥민감 문법|문맥민감 언어 (context-sensitive language)|선형 바운드 오토마타 (linear-bounded automata)|
    |타입 2: 문맥자유 문법|문맥자유 언어 (context-free language)|푸쉬다운 오토마타 (push-down automata)|
    |타입3: 정규 문법|정규 언어 (regular language)|유한 상태 기계 (linear state machine)|

    - 정규문법 ⊆ 문맥자유문법 ⊆ 문맥민감문법 ⊆ 무제한문법
    - 정규언어 ⊆ 문맥자유언어 ⊆ 문맥민감언어 ⊆ 재귀나열언어
    - 유한상태기계 ⊆ 푸쉬다운 오토마타 ⊆ 선형 바운드 오토마타 ⊆ 튜링 기계

- 프로그래밍 언어의 구문 분석
    - 프로그래밍 언어의 문법은 정규 문법과 문맥자유문법이면 표현하기 충분함
    - 프로그래밍 언어의 구문 분석은 유한 상태 기계와 푸쉬다운 오토마타를 이용
    - 컴파일러의 구문구조 분석 단계
        1. 어휘 분석 (lexical analysis, scanning)
            - 프로그램 어휘들을 정규 문법으로 표현하고 유한 상태 기계로 인식함
        2. 구문 분석 (syntatic analysis, parsing)
            - 프로그램 구조를 문맥자유 문법으로 표현하고 푸쉬다운 오토마타로 인식함

## 변수의 속성

- von Neumann 구조
    - 명령형 언어는 폰노이만 구조의 컴퓨터를 구현한 형태이다.
        - 폰 노이만 구조 : 명령형언어
        - 메모리 : 변수
        - 프로세서 : 수식 연산

- 변수의 속성
    1. 이름 (name)
        - 무명 변수 (Anonymous Variable)
            - 이름이 주어지지 않는 변수도 있을 수 있다.
            ```
            int *p = (int *) malloc(sizeof(int));
            // 동적할당된 무명변수를 *p로 접근할 수 있다.
            ```
    2. 타입 (type)
        - 타입으로부터 알 수 있는 정보
            - 값의 범위 (range of values)
            - 적용 가능한 연산의 종류 (set of operations)
            - 유효숫자의 범위 (precision): 실수형의 경우
            - 16-bit 정수형으로 알 수 있는 정보:
                1. 값의 범위: -32768 ~ 32767
                2. 연산의 종류: +, -, *, /, mod, ...
            - Stack class로부터 알 수 있는 정보:
                1. 값의 범위: class 내에 member 데이터로 선언된 변수의 타입에 따라 좌우된다.
                2. 연산의 종류: class 내에 member 함수로 선언된 pop, push, ...
    3. 주소 (address)
        - 프로그램에서 사용되는 변수는 타입 크기만큼의 기억장소가 대응된다.
        - 변수에 대응된 기억장치의 주소를 변수의 주소라고 한다.
        - 한 변수의 주소는 실행 시점에 따라 다를 수 있다.
        - 동일한 이름의 변수는 프로그램에서 사용된 위치에 따라 주소가 다를 수 있다.
        ```
        int x;              // 전역변수
        foo() { int x; }    // foo의 지역변수
        goo() { int x; }    // goo의 지역분수
        ```
        - 하나의 기억장소에 여러개의 변수 이름이 대응될 수 있다. (alias 현상)
            - 가동성 저하
    4. 값 (value)
        - 변수에 대응되어 있는 기억장소에 저장되어 있는 값
        - 변수의 값의 종류:
            1. 변수의 l-value: 변수의 주소 (address)
            2. 변수의 r-value: 변수의 값 (value)
            ```
            int k;
            k = 3; // k: l-value
            k = k + 5; // 왼쪽 k는 l-value 오른쪽 k는 r-value
            ```
        - 인자전달 (parameter passing)
            1. Call-by-value (값-전달): r-value를 전달
            2. Call-by-reference (참조-전달): l-value를 전달
    5. 영역 (scope)
    6. 존속기간 (lifetime)
- Alias (별칭)
    - 여러개의 이름으로 변수에 접근할 수 있는 것을 alias라 한다.
    - Alias 현상이 발생하는 경우
        - Pointer 사용
            ```
            int *p, *q;
            p = q = (int *)malloc(...);
            ```
        - 참조변수 (Reference variable) 사용
            ```
            int ans;
            int &ref_ans = ans;
            ```
        - union 사용
            ```
            union {
                int p;
                float q;
            } a;
            ```
        - Call-by-Reference에 의한 인자 전달
            ```
            void foo(int &x, ...) { ... }
            main() {
                int a;
                foo(a, ...);
                ...
            }
            ```
- 바인딩 (Binding)
    - 변수에 속성을 부여하는 것을 바인딩이라고 한다.

## 변수의 바인딩

- 바인딩
    - 개체에 어떤 속성을 맺어주는 것
    - 변수의 바인딩
        - 변수에 변수와 관련된 속성을 맺어주는 것
        ```
        int age; // 변수 age에 타입을 바인딩 - 타입 바인딩
        age = 19; // 변수 age에 값을 바인딩 - 값 바인딩
        ```
    - 연산자(operator)의 바인딩
        - 기호(symbol)에 연산(operation)의 의미를 맺어주는 것
        - `'+'`: 더하기(add)
        - `'*'`: 곱하기(multiply)
    - 바인딩 시점 (Binding time)
        - 바인딩이 이루어지는 시점
        - 바인딩 되는 속성에 따라 다름

- 대표적인 바인딩 시점
    1. 정적 바인딩 (Static Binding)
        1. 프로그래밍 언어를 설계할 때
            - 연산자 기호 `+`가 더하기 임은 언어 설계에서 정한다
        2. 프로그래밍 언어를 구현할 때 (compiler/interpreter를 작성할 때)
            - 정수형 값의 범위: 16-bit/32-bit 임에 따라 달라진다
        3. 프로그램을 컴파일할 때
            - 변수의 타입
        4. 프로그램을 메모리에 Load할 때
            - 전역 변수/static 변수의 주소
    2. 동적 바인딩 (Dynamic Binding)
        1. 프로그램을 실행할 때
            - static이 아닌 지역변수의 주소
            - 부프로그램의 인자 주소
            - 동적으로 할당된 기억장소의 주소

- 정적바인딩 vs 동적 바인딩
    |정적바인딩|동적바인딩|
    |--|--|
    |최초의 바인딩이 프로그램 실행하기 전에 이루어진다.|최초의 바인딩이 프로그램 실행하는 동안 이루어진다.|
    |한번 바인딩이 이루어진 속성은 프로그램이 종료될 때까지 변하지 않는다.|한번 바인딩이 이루어진 속성이 프로그램 실행 과정에서 다시 발생하는 바인딩에 의해서 다른 속성으로 변할 수 있다.|

- 변수의 타입바인딩 (Type Binding)
    1. 명시적 선언 (explicit declaration)
        - 변수의 타입을 지정하는 선언문에 의해서 타입이 지정된다.
        - 신뢰성 향상
    2. 묵시적 선언 (implicit declaration)
        - 언어 설계 시 정의된 규칙에 의해서 변수의 타입이 지정된다.
        - 프로그램에서 변수가 처음 나타나는 지점에서 타입이 지정된다.
        - Fortran에서,
            - 정수형: 변수 이름이 I, J, .., N으로 시작
            - 실수형: 변수 이름이 기타 문자로 시작
        - 작성력 향상
        - 신뢰성 하락
    3. 값의 배정
        - 배정문을 실행할 때 타입이 지정된다.
        - JavaScript에서,
        ```javascript
        list = [2, 4, 6]; // list: 1차원 배열
        list = 17.3; // list: 실수형 스칼라 변수
        ```
        - 장점
            1. 유연성(flexibility) 향상
                - 모든 타입에 적용될 수 있는 부프로그램(generic subprogram)을 작성하는 것이 가능하다.
        - 단점
            1. 프로그램 실행 비용 증가
                - 타입검사(type checking)가 프로그램 실행 시 이루어진다
            2. 타입오류를 발견하기가 어려움
                - 하 ㅅㅂ..
    4. 타입 추론 (Type inference)
        - 변수가 사용된 주변 상황에 의해서 타입이 지정된다.
        - 주로 함수형 언어에서 적용
            - ML 언어에서,
            ```
            fun curcumf(r) = 3.14 * r * r;
            // r: 실수형
            fun times10(x) = 10 * x;
            // x: 정수형
            fun square(x) = x * x;
            // x의 타입 모르겠당 에러
            // 해결방법
            fun square(x): int = x * x;
            ```
- 변수의 타입바인딩 시점
    |정적바인딩|동적바인딩|
    |--|--|
    |대부분이 컴파일러 언어에서 프로그램을 컴파일할 때 타입바인딩이 이루어진다.|대부분의 인터프리터 언어에서 프로그램을 실행할 때 타입바인딩이 이루어진다.|
    |대부분, 명시적 또는 묵시적 선언 방법에 의해서 타입이 지정된다.|대부분, 값의 배정 방법에 의해서 타입이 지정된다.|
- 변수의 부류
    - 변수의 기억장소 바인딩과 관련된 주제
        1. 기억장소 할당 (Allocation)
            - 사용되지 않고 있는 기억장소에서 변수 타입의 크기만큼의 공간을 변수에 할당함.
        2. 변수의 존속기간 (Lifetime)
            - 변수에 기억장소가 할당되는 시점부터 반환되는 시점까지의 기간
        3. 기억장소 반환 (Deallocation)
            - 변수에 할당된 기억장소를 사용되지 않는 공간으로 반환함.
            - 반환된 기억장소는 나중에 할당 요청이 있을 때 다시 할당될 수 있음.
    - 변수의 존속기간에 따른 스칼라 변수의 부류
        1. 정적(Static) 변수
            - 프로그램 실행 전에 메모리의 정적영역에서 할당이 이루어짐
            - 장점
                1. 프로그램 실행의 효율성
                    - 변수에 직접 접근할 수 있음 (direct addressing)
                    - 기억장소의 할당 및 반환 시간이 필요 없음.
                2. 부프로그램(subprogram)에서 과거-민감(history-sensitive)변수 지원
                    - 과거민감 변수는 프로그램 실행 과정에서 어떤 시점에서 그 이전에 변수가 가진 값에 현시점에 영향을 미치는 변수.
                    - 부프로그램을 호출해서 실행을 시작할 때, 이전 호출에서 마지막으로 배정된 값을 갖는다.
            - 단점
                1. 재귀적(recursive) 부프로그램 작성이 불가능함.
                2. 지역변수들 사이에 기억장소를 공용할 수 없음.
        2. 스택-동적(Stack-dynamic) 변수
            - 프로그램이 실행되는 과정에서 메모리의 스택영역에서 할당이 이루어짐
            - 스칼라 변수의 경우 다른 속성(이름, 타입, 영역)은 정적으로 바인딩 되기도 한다.
            - 장점
                1. 재귀적 부프로그램 작성이 가능함.
                2. 지역변수들 사이에 기억장소를 공용할 수 있음.
            - 단점
                1. 프로그램 실행 시간의 증가
                    - 기억장소의 할당 및 반환 시간이 추가적으로 필요함.
                    - 변수에 간접적으로 접근해야 함. (in -direct addressing)
                        - 스택포인터 + 오프셋으로 주소 값을 계산해야함
                2. 부프로그램에서 과거-민감 변수를 이용할 수 없음.
                    - 부프로그램의 지역변수를 할당했다 반환해야 하므로 흔적이 사라져버림.
        3. 명시적 힙-동적(Explicit heap-dynamic) 변수
            - 기억장소를 할당하는 문장을 실행할 때 heap영역의 기억장소가 바인딩 되고, 반환하는 문장을 실행할 때 반환된다.
            - 포인터나 참조변수를 통해서 접근할 수 있다.
            - 링크드리스트나 트리와 같이 프로그램 실행 중에 크기가 커지거나 줄어드는 경우에 사용된다.
            - 장점
                1. 필요에 따라 기억공간을 효율적으로 관리하여 사용할 수 있다.
            - 단점
                1. 포인터나 참조변수를 올바르게 사용하기 어려워 신뢰성 저하
                2. 기억장소의 동적 할당 및 반환에 필요한 실행시간 증가
                ```c
                // c
                int *p = (int *)malloc(sizeof(int));
                free(p);
                ```

                ```cpp
                // c++
                int *p = new int;
                delete p;
                ```
        4. 묵시적 힙-동적(Implicit heap-dynamic) 변수
            - 배정문을 실행할 때 기억장소가 바인딩 된다.
                - JavaScript의 문자열:
                ```javascript
                var st = "Hong"; // 길이: 4
                st += "Gil-Dong"; // 길이: 13
                ```
                - JavaScript의 배열:
                ```javascript
                var na = new Array(34, 52, 19); // 크기: 3
                na[8] = 68; // 크기: 9
                ```
            - 쓸모가 없어진 기억장소는 보통 시스템에 의한 쓰레기수집(garbage collection)을 통해 반환된다.
            - GC 만세
            - 장점
                1. 유연성 향상
                    - 기억장소를 필요할 때 할당하고 필요가 없어졌을 때 반환.
                    - 모든 타입에 적용될 수 있는 포괄형 코드(generic code) 작성이 가능.
            - 단점
                1. 기억장소의 동적 할당 및 반환에 필요한 실행시간 증가
                2. 컴파일할 때 오류를 검출할 수 없다.

- 이름상수 (Named Constant)
    - 변수 이름에 기억장소 바인딩이 이루어질 때 값 바인딩이 동시에 이루어진다. 한번 바인딩 된 값은 변경될 수 없다.
    - 바인딩 방법에 따른 이름상수의 분류
        1. 정적 바인딩에 의한 이름상수 : 명확 상수(manifest constant)라고 부름
        2. 동적 바인딩에 의한 이름상수
    - 장점
        1. 가독성 및 신뢰성 향상

## 변수의 타입검사

- 타입 검사 (Type Checking)
    - 연산자(operator)와 피연산자(operand)로 이루어진 수식(expression)에 대해 타입을 검사하고 오류를 검출하는 것
    - 타입검사 방법
        - 연산자의 피연산자들이 서로 호환가능 타입(compatible type)인지 확인.
        - 연산자의 피연산자들이 호환가능 타입이 아닐 때 타입오류 발생.
    - 수식에 적용되는 개념을 함수와 배정문(assignment statement)까지 일반화할 수 있다.
- 타입바인딩에 따른 타입검사
    1. 모든 타입바인딩이 정적(static)인 경우
        - 거의 모든 타입검사가 정적
        - 장점
            - 타입오류를 일찍 검출
            - 실행 시간이 빠름
        - 단점
            - 유연성 부족
            - 타입이 한번 결정되면 바뀌지 않음.
    2. 모든 타입바인딩이 동적(dynamic)인 경우
        - 모든 타입검사는 반드시 동적
        - 장점
            - 유연성 향상 (필요한대로 타입 변경 가능)
        - 단점
            - 타입오류를 늦게 검출
            - 타입오류 해결 비용 증가
            - 타입바인딩 및 타입검사가 실행시 이루어지므로 실행 시간이 증가
- 강 타입 (Strong Typing)
    - 프로그래밍 언어 설계 시 가장 중요한 개념 중의 하나.
    - 강 타입 언어 (STrong Typing)
        - 타입 과 관련된 오류를 항상 검출할 수 있는 언어
        - 조건: 모든 타입이 컴파일할 때나 실행할 때 결정될 수 있어야 한다.
    - 강 타입 언어가 되지 못하는 원인
        1. Coercion 지원 (묵시적 타입 변환)
            - 프로그래머의 의도와 달리 타입이 변환될 수 있음.
            - C/C++는 coercion을 너무 많이 허용함. ㅈ망언어
        2. 타입검사를 지원하지 않는 기억장소 공유 (alias의 하나)
            - C/C++의 union, C#의 StructLayout
        3. 부프로그램 호출 시 전달되는 인자의 타입검사를 안하는 경우
            - C에서 `int foo(fa) int fa; { ... }`
        4. 가변 record
        5. 프로그래머가 타입검사 중단을 명시할 수 있는 기능
            - Ada의 Unchecked_Conversion
            - C#의 dynamic 키워드
- 타입호환성 (Type Compatibility)
    - 피연산자의 타입이 호환가능 타입(compatible type)인 경우
        - 피연산자의 타입이 연산자에 적법
        - 피연산자의 타입이 coercion에 의해서 연산자에 적법한 타입으로 변환될 수 있음.
    - 강 타입 언어 (STrong Typed Language)
        - 이름 타입호환성 (name type compatibility)
            - 이름 타입호환성을 적용할 경우, 두 변수가 호환가능 타입이 되는 경우
                - 두 변수가 동일한 선언문에서 선언된 경우
                - 두 변수의 타입 이름이 동일한 경우
                ```
                type Atype = array [1..12] of real;
                var a1, a2: array [1..12] of real;
                    b: array [1..12] of real;
                    c: Atype;
                    d: Atype;ㅏ
                    호환가능 타입: (a1, a2), (c, d)
                ```
                - 구현하기는 쉬우나 사용 면에서 상당히 제한적이다.
                    - Ada: 정수의 부분범위(subrange) 타입은 정수형과 호환적이지 않다.
                    ```
                    type Indextype 0..100;
                    index: Indextype; count: Integer;
                    ```
                    - Pascal: 형식인자와 실인자는 타입 이름이 동일해야 한다.
                    ```
                    program main; // Error
                        var x: array [1..12] of real;
                        function foo(y:array[1..12] of real, ...) :real;
                    begin ... foo(x, ...); ... end.
                    ```
        - 구조 타입호환성 (struct type compatibility)
            - 구조 타입호환성을 적용할 경우, 두 변수가 호환가능 타입이 되는 경우
                - 각 변수의 타입 구조가 서로 동일한 구조일 경우
                - 구현하기는 어려우나, 사용 면에서 유연하다.
            - 문제점
                - 두 개의 구조체가 구조는 동일하나, field 이름이 다를 경우
                ```c
                struct foo { int a; float b; }
                struct goo { int x; float y; }
                ```
                - 두 개의 열거형이 원소 개수는 같으나, 원소 이름이 다를 경우
                ```c
                enum foo { mon, tue, wed };
                enum goo { jan, feb, mar };
                ```
                - 두 개의 배열이 크기는 같으나, 첨자의 범위가 다를 경우
                ```pascal
                var a: array [0..11] of integer;
                    b: array [1..12] of integer;
                ```
                - 하나의 타입 이름으로 두 개의 새로운 타입을 정의했을 경우
                ```pascal
                type celcius = real;
                     fahrenheit = real;
                ```
                - 이상이 구조는 같지만 단위(unit)나 척도(scale)가 다를 수 있다.
    - 강 타입 언어가 되지 못하는 원인
        - 기본(primitive) 데이터타입의 경우 이름과 구조가 동일하기에 호환성 검사에 문제가 발생하지 않음.
        - 사용자 정의 데이터타입의 경우 이름 타입호환성이나 구조 타입호환성 하나만을 엄격하게 준수하는 언어는 없음.
    - Ada의 타입호환성
        - 일반적으로 이름 타입호환성 사용
            1. 파생타입 (derived type)
                - 기존 타입과 호환가능하지 않음
                ```ada
                type celsius    is new Float;
                type fahrenheit is new Float;
                - celsius, fahrenheit, Float는 서로 호환가능하지 않음
                ```
            2. 부분타입 (subtype)
                - 부모타입(parent type)과 호환가능
                ```ada
                subtype Small_type is Integer range 0..99;
                - Small_type은 Integer와 호환 가능.
                ```
            3. 제한 무명 타입 (constrained anonymous type)
                - 변수는 모두 독립적
                ```ada
                A, B : array (1..10) of Integer;
                type List_10 is array (1..10) of Integer;
                C, D : LIST_10;
                - 호환가능: (C, D)
                ```
            4. 비제한 배열 타입 (unconstrained array type)
                - 구조 타입 호환성이 적용
                ```ada
                type Vector is array (Integer range <>) of Integer;
                Vector_1: Vector (1..10);
                Vector_2: Vector (11..20);
                - Vector_1과 Vector_2는 호환가능하다
                ```
            5. 산술연산자의 피연산자에 대한 coercion은 없음
                ```ada
                3.14 * 29 // Error
                ```
    - C의 타입호환성
        - struct, union, enum 타입은 이름 타입호환성을 적용
            - 모든 각각의 선언은 새로운 타입을 생성하는 것으로 간주.
            ```c
            struct { int n; float x; } a1, a2;
            struct { int n; float x; } b1, b2;
            - 호환가능: (a1, a2), (b1, b2)
            ```
        - 배열은 구조 타입호환성을 적용
            ```c
            int A1[7]; int A2[10]; int A3[];
            - A1, A2, A3가 모두 호환 가능
            ```
        - typedef로 정의된 타입은 부모 타입과 동일
            - typedef로 정의된 타입은 새로운 타입을 생성하는 것이 아님
            ```c
            typedef struct { int n; float x; } Stype;
            Stype a; Stype b;
            struct { int n; float x; } c;
            - 호환가능: (a, b)
