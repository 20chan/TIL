# 언어론 공부

## 언어론 소개

### 프로그래밍 도메인

1. 과학 계산
    - 다양한 실수형 연산
2. 기업 경영
    - 보고서 작성, 10진수 및 문자열을 주로 다룸
3. 인공지능
    - 수 보다는 심볼을 주로 다룸
4. 시스템 프로그래밍
    - 운영체제와 같은 시스템 소프트웨어는 항상 실행상태에 있으므로 효율적이어야 한다.
5. 웹 소프트웨어
    - **갓언어 PHP**

### 프로그래밍 언어의 범주

1. 명령형 (Imperative)
    - 주로 변수, 할당문, 반복문 등을 이용하여 프로그램을 작성함.
2. 함수형 (Functional)
    - 매개변수를 받아 실행하는 함수를 이용하여 프로그램을 작성함.
3. 논리형 (Logical)
    - 순서가 중요하지 않는 규칙을 기반으로(rule-based) 프로그램을 작성함.
4. 객체지향형 (Object-oriented)
    - 명령형 언어에 기반
    - 데이터의 캡슐화 (encapsulation), 속성의 상속 (inheritance), 동적 타입 바인딩 등을 이용하여 프로그램을 작성함

## 언어 평가 기준

1. 가독성 (Readability)
    1. 간결성 (Simplicity)
        - 너무 많은 종류의 문장을 지원하는 언어는 좋지 않다
        - 동일한 기능의 연산 표현 방법이 많을수록 좋지 않다
        - 연산자 오버로딩은 프로그램을 이해하는데 좋지 않은 기능이다
        - 함수형 언어가 간결성에서 우수함
    2. 직교성 (Orthogonality)
        - 수학에서 직교하다와 같은 의미
        - 언어의 모든 구성 요소를 임의로 조합해서 프로그램을 작성할 수 있는 기능
        - 직교성이 부족: 구성 요소의 사용 규칙에 예외적인 경우가 많음
        - 완벽에 가까운 직교성: 상식적이지 않은 조합은 표현이 복잡해져 가독성을 저하시킬 수 있음
        - 함수형 언어가 직교성에서 우수함.
    3. 제어문 (Control statements)
        - goto문이 있는데 가독성에 좋지 않음
        - if-then-else나 while 등의 구조적 프로그래밍 구조를 지원하면서 제어문의 중요성은 저하되었다.
    4. 데이터 타입과 구조체 (Data types and Structures)
        - 적절한 data type이 지원되어야 하고 새로운 자료구조를 data type으로 정의할 수 있어야 한다.
    5. 문법의 구문 (Syntax)
        - 식별자(Identifier)의 형태
            - 길이에 제한이 있는 경우 가독성이 떨어진다
            - 특수 문자를 식별자에 사용가능하면 가독성이 좋다. (`_` 등)
        - 특수 단어 (Special words)
            - 의미를 자연스럽게 알 수 있는 특수 단어들은 가독성에 좋다.
        - 형식과 의미 (Form and meaning)
            - 포현 형식은 같거나 비슷한데 경우에 따라 다른 의미를 가지면 가독성이 떨어진다.
2. 작성력 (Writability)
    1. 간결성 (Simplicity)
        - 소수의 구성 요소
        - 구성 요소들의 조합에 대한 소수의 규칙
    2. 직교성 (Orthogonality)
        - 모든 구성 요소의 임의의 조합이 가능하므로 작성력이 좋다.
        - 지나친 직교성은 작성력에는 좋을지라도 가독성에 좋지 않은 면이 있다.
    3. 추상화 (Abstraction) 지원
        1. 데이터의 추상화 (Data abstraction)
            - 복잡한 자료구조를 정의해서 사용할 수 있는 기능 지원
        2. 프로세스의 추상화 (Process abstraction)
            - 복잡한 연산을 정의해서 사용할 수 있는 기능 지원 (function, procedure 등)
    4. 표현력 (Expressivity)
        - 기존의 구성 요소와 동일한 기능을 수행하지만 좀 더 편리한 구문 지원
            - 중첩된 if-then-else 대신 switch문
            - counter를 사용하는 while 대신 for문
        - APL 언어는 매우 강력한 연산자를 지원함
            - 하나의 연산으로 행렬 더하기 곱하기 전치행렬 구하기 등이 된다
            - 작성력은 매우 뛰어나나 가독성이 매우 떨어짐
3. 신뢰성 (Reliability)
    1. **Type checking**
        - 컴파일할 때나 프로그램 실행 시 타입 에러를 검출함.
        - 일찍 발견할수록 오류 수정 비용이 적다.
    2. 예외 처리 (Exception handling)
        - 프로그램 실행시 런타임 에러가 발생한 경우, 이를 인식하고 오류를 처리할 수 있는 필요한 조치를 취할 수 있는 기능
    3. Aliasing
        - 메모리의 한 저장 장소를 여러 이름으로 접근할 수 있는 기능 (C의 union 등)
        - 신뢰성에 부정적인 영향을 끼친다.
    4. 가독성과 작성력
        - 작성하기 쉽고 이해하기 쉬운 프로그램을 작성할 수 있는 언어로 작성된 프로그램은 오류 가능성이 적다.
4. 비용 (Cost)
    1. 프로그래머 양성 비용
        - 간결성과 직교성의 영향을 받음
    2. **프로그램 개발 비용**
        - 작성력과 특정 응용분야와의 밀접성의 영향을 받음
    3. 프로그램의 컴파일 비용
    4. 프로그램의 실행 비용
        - 언어 설계의 영향을 받음
        - 컴파일 비용과 상충관계
    5. 컴파일러/인터프리터의 비용
        - 언어 구현 시스템이 저렴하면 널리 사용됨
    6. **신뢰성**
        - 신뢰도가 낮은 언어로 작성된 프로그램은 오류로 인한 비용 부담이 매우 크다
    7. **유지보수 (maintenance) 비용**
        - 가독성과 작성력의 영향을 받음

## 구문구조

### 구문구조와 의미구조

- 정형언어
    - 프로그래밍 언어는 정형 언어이다. (vs, 자연언어)
    - 정형 언어는 자연언어보다 명확하고 모호하지 않은 형태와 의미를 가진다.

1. 프로그래밍 언어
    - 프로그램들의 집합
2. 알파벳
    - 어떤 언어의 문장을 만드는 데에 사용할 수 있는 모든 문자들의 집합
3. 문법
    - 어떤 언어의 알파벳으로부터 문장을 만들기 위해 사용하는 규칙들의 집합
4. 구문 분석
    - 어떤 문장이 어떤 언어의 원소인지, 즉 문법을 만족하는 지를 분석하는 과정

### 문자열 집합과 연산

> ε 는 빈 문자열

- 문자열 접합 연산
    - `"ab" . "cd" = "abcd"`
    - `"ab" . ε = ε . "ab" = "ab"`
- 문자열 집합 접합 연산
    - `{"a", "ab"} . {"c", "d"} = {"ac", "ad", "abc", "abd"}`
    - `{"a", "b"} . {} = {} . {"a", "b"} = {"a", "b"}`
    - `{"a", "b"} . {ε, "c"} = {"a", "ac", "b", "bc"}`
- 문자열 연산의 간략형
    - `{a, b} . {a, b} = {a, b}² = {aa, ab, ba, bb}`
    - `{a, b} . {a, b} . {a, b} = {a, b}³ = {aaa, aab, aba, abb, baa, bab, bba, bbb}`
    - `{a, b}¹ = {a, b}`
    - `{a, b}^0 = {ε}`
- 클레이니 클로저 (Kleene Closure)
    - `{a, b}* = {a, b}ⁿ = {a, b}^0 ∪ {a, b}¹ ∪ {a, b}² ∪ ...` (문자 a, b로 이루어진 모든 문자열들의 집합)

### 언어 집합

#### 간단한 언어 Simple

- 언어 Simple의 알파벳 `Σ = {a, b}`
- `Simple = {a, ab, abb, abbb, abbbb, ...}`
- `Simple ⊆ Σ*`
- `Simple = {w|문자열 w는 어떤 조건을 만족한다} = {w|문자열 w는 맨 앞에 a가 나오고 그 다음에 0개 이상의 b가 나온다}`

#### 귀납 정의

- 무한 집합 Simple을 유한하게 작성하는 방법
- 추론 규칙
    - `a ∈ Simple` (공리)
    - `w ∈ Simple 이면 wb ∈ Simple` (추론규칙)
    - abb가 Simple의 원소임을 증명하려면?
        1. `a ∈ Simple`
        2. `ab ∈ Simple`
        3. `abb ∈ Simple`
- 생성 규칙: 화살표 기반의 기호열을 우변의 기호열로 교체할 수 있음을 의미
    - `S -> a`
    - `S -> Sb`
    - 문장 abb가 Simple의 원소임을 증명하는 유도 (derivation)
        - `S -> Sb -> Sbb -> abb`
    - 문장형태 (sentential form): 시작기호로부터 문장에 이르기까지 유도에 등장하는 기호열
    - 문장 abb가 Simple의 원소임을 증명하는 파스트리
    ```
       S
      / \
     S   \
    /  \  |
    S  |  |
    |  |  |
    a  b  b
    ```

### 언어의 문법

- 정형 문법 G=(T, N, S, P)
    1. 터미널 기호 집합 T
    2. 넌터미널 기호 집합 N
    3. 시작 기호 S
    4. 생성규칙의 집합 P

- Simple의 정형 문법 G
    1. `T = {a, b}`
    2. `N = {S}`
    3. `S`
    4. `P = {S->a, S->Sb}`
        혹은 `P = {S -> a | Sb}`

- 다른 언어 G2의 문법
    1. `T = {a, b}`
    2. `N = {S, A, B}`
    3. `S`
    4. 생성규칙의 집합 P
        - S -> aAb | aBb
        - A -> aA | ε
        - B -> bB | ε
    ```
    L(G2) = {ab, aab, aaab, ..., abb, abbb, ...}
    ```

> 생성규칙에서 각 넌터미널은 하나의 부분언어 집합을 나타낸다.

#### BNF 구문 정의

- BNF (Backus-Naur Form)
    - 프로그래밍 언어의 문법을 표현하기 위한 표기법
    - Algol 60 정의에 처음 사용함
    - 프로그래밍 언어의 대부분을 표기하기 위해 사용함


- 간단한 예제 프로그래밍 언어를 위한 문법
    ```bnf
    <program> ::= <stmts>
    <stmts> ::= <stmt> | <stmt> ; <stmts>
    <stmt> ::= <var> = <expr>
    <var> ::= a | b | c | d
    <expr> ::= <term> + <term> | <term>
    <term> ::= <var> | const
    ```
    - `a = a + b ; b = c`
        ```
        유도: <program> -> <stmts>
        -> <stmt> ; <stmts>
        -> <var> = <expr> ; <stmts>
        -> a = <expr> ; <stmts>
        -> a = <term> + <term> ; <stmts>
        -> a = <var> + <term> ; <stmts>
        -> a = a + <term> ; <stmts>
        -> a = a + <var> ; <stmts>
        -> a = a + b ; <stmts>
        -> a = a + b ; <stmt>
        -> a = a + b ; <var> = <expr>
        -> a = a + b ; b = <expr>
        -> a = a + b ; b = <term>
        -> a = a + b ; b = <var>
        -> a = a + b ; b = c
        ```
        - 좌(우)우선 유도(left(right) most derivation) : 유도 단계마다 맨 왼쪽(오른쪽)에 위치한 넌터미널을 대치함
        - 좌우선이든 우우선이든 파스트리는 동일하게 생성됨
        - 파스트리
        ```
                               <program>
                                   |
                                <stmts>
                  /                |         \
             <stmts>               |        <stmts>
          /    |      \            |           |
        <var>  |      <expr>       |        <stmts>
          |    |    /    |    \    |      /    |    \
          |    |  <term> | <term>  |    <var>  |  <expr>
          |    |    |    |    |    |      |    |    |
          |    |   <var> |  <var>  |      |    |  <term>
          |    |    |    |    |    |      |    |    |
          |    |    |    |    |    |      |    |   <var>
          |    |    |    |    |    |      |    |    |
          a    =    a    +    b    ;      b    =    c
        ```